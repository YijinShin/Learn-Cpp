/*
디자인 패턴 
c++이후에 등장함. 
디자인 = 클래스들의 관계를 설계하겠다. 패턴 = 공통화 된 작업을 하나의 로직으로 만들겠다. 

오늘은 반복자 패턴, 추상패턴을 공부할거임  "리팩터링과 디자인패턴. 리팩토링.guru" 블로그참고

요즘에는 면접때 디자인 패턴을 막 물어보지는 않는다. 

===============================================================================================

추상 팩토리 패턴: 생성 패턴의 한 종류로 인스턴스르 만드는 절차를 추상화한 패턴
[ 생성 이후에 동일한 행동을 하는 객체들은 -> 이러한 방법으로 생성하자 ] 이런식으로 정해놓는... 그런건듯 
"객체 생성할때는 이렇게 하자" 라고 정의하는것. 
 클래스 만들때 인라인 체크하면 헤더파일만 만듬. 

 클래스 템플릿 만들꺼니까 인라인 체크하고 만들자. 
 클래스 템플릿을 만들고, 그 안에 Obj를 할당해서 반환하는 create()함수를 만듬. 
 Obj 객체는 앞으로 클래스 템플릿의 create를 써서 만든다. 뭐 이런거임. 
 CObj* m_pPlayer = CAbstructFactor<CPlayer>::Create();	// 이런식으로 객체를 만드는 것. 

===============================================================================================

반복자 패턴 : 내부 표현 방식은 공개하지 않고 순차적인 접근 방법을 제공하는 패턴

새로운 열거체를 하나 선언한다.( 선생님은 열거체만모아두는 헤더파일을 하나 만드심) 

// 이 열거체는 오브젝트 종류를 구분하기 위함. 
enum ObjEnum {OBJ_PLAYER, ....., OBJ_END} 

list<CObj*> m_ObjList[OBJ_END];	// 오브젝트 배열들의 리스트. 각 종류별 오브젝트 배열의 첫 주소값을 가지고있는 리스트인것. 

그럼 이제 플레이어를 만들때 
m_ObjList[OBJ_PLAYER].push_back(CAbstructFactor<CPlayer>::Create())
 이런식으로.. 하는거임 

 이렇게 되면 update, render쪽은 아무리 오브젝트가 추가되도 건드릴 필요가 없어짐. 
 그족에서는 그냥 
	
for(size_t i=0;i<oBJ_END;i++){
	for(auto* iter = m_objList[i].begin())
		(*iter)->Render(m_DC);	
	}
이렇게 반복문으로 다 접근해서 렌더 시키면되니까

장점: 못들음 
단점: 진입장벽이 높아지고(디자인 패턴 잘 모르는 사람들한테 코드가 어려워짐) 
	, 코드 결합... 못들음

물론 실무에서는 각자 다른 디자인 패턴을 사용함. 그냥 알아만 두기 
5개월차때 또 다른거 배울거임. 
===============================================================================================

과제 피드백 + 디자인패턴 결합하기 

update에서 int반환하잖아 그거 이제 디파인한 값 1,0으로 
update하고 오브젝트가 죽지 않으면 OBJ_NOEVENT 반환
죽으면 oBJ_DEAD
OBJ_DEAD면 해당 오브젝트를 safe_delete하기 
어떤 오브젝트간에 데드 뜨면 저렇게 처리하라고 공통화 시키는 것. 

그럼이제 총알을 어떻게 데드 상황으로 만들것인가. 

불릿의 업뎃에서, 
	자기자신이 죽었으면 OBJ_DEAD를 리턴하도록만듬. 
그럼 삭제는 언제하나. 
총알의 update_rect이후에, 죽었는지 처리해야함. 당연함. 
먼저 다음 위치를 계산하고, 그 담에 데드 판정을 해야지 

여기서 레이트 업데이트라는 계념이 등장

업데이트 끝나고, 그리기를 실행하기 전에 그 이에 뭔가 판정이나 연산을 하고싶으면 (업데이트 연산이 끝난 그 즉시) 레이트 업데이트에서
하는거지

MainGame에서 update나 rander같이 lateupdate를 만들고, 거기에서 각 오브젝트들이해야할 레이트 업데이틀를 호출하는식

그 윈도우 메인에서도 update, rander사이에 lateupdate넣어줘야하는거 잊지말기 

총알의 레이트 업데이트함수에는 데드 판정을 하는 내용을 넣기 
===============================================================================================

문자열 출력 함수 

* TextOut();
	TCHER szBuff[32] = L"Hello"	//64바이트임..	// 문자열 초기화 하려면 L""
	TextOut(m_DC, 50, 50, szBuff, lstrlen(szBuff));	// 출력할 dc, x좌표, y좌표 출력할 문자열 주소, 출력할 문자열 크기 
	lstrlen = 유니코드 문자열 길이 구하는것. 

	wsprintf()로 총알 개수 출력하기 
	총알은 m_oBjlist[OBJ_BULLET].size()로 구할수있음

* DrswText();	
	출력할 dc, 출력할 문자열 주소, 문자열 크기, rect주소, 정렬 기준 

wsprintf는 소수점 자리 이하는 출력 불가능	// win api에서 제공하는거라 모든 서식을 지원하지 않음 
swprintf_s	//소수점 아래 출력 가능. 실수값 출력가능	// visual c++에서 지원함. 모든 서식을 제공한다. 


===========================================================================

과제

미사일로 몬스터를제거하고, 미사일도 제거하기 

발사한 미사일로 몬스터를 삭제하라
총알도 삭제되야함. 

충돌 처리 함수가 있다. IntersectRect()함수 
인자: 렉트의 주소를 3개 요구함. 
결과 값 렉트 주소, 충돌할 오브젝트 1의 렉트, 충돌할 오브젝트 2의 렉트 
불타입 반환함.


과제2

피타고라스의 정리를 공부하고 와라 


*/