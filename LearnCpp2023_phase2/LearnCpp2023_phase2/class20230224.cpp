/*
[ 과제 피드백 ]
- main.cpp에서는 클래스만부르는식으로 바꾸기 maingame.h따로 둬서. 
- release에서 
	safe delete 하는걸로 고쳐보기 (clear보다 delete를 먼저해야함)
	이것도 vector사이즈만큼 다 해줘야함
--------------------------------------------------
[반복자]
컨테이너 원소 접근, 읽기, 쓰기를 하기 위한 객체 

반복자의 종류
	()안에 있는거는 연산자 오버로딩
- 출력 반복자 (몰라도됨) 메모리 공간 접근해서 읽기만 가능 쓰기 안됨 ( *)
- 입력 반복자 (몰라도됨) 메모리 공간 접근해서 읽기, 쓰기 가능: (*, =)
- 순방향 반복사 (몰라도됨) 마치 포인터 연산처럼 동작함. 0번원소를 가지고 있는 반복자에 ++하면 1번째 원소를 가리키게됨. 포인터랑은 살짝 다름.: ++ 
4. 양방향 반복자:  순방향+ 역방향 이동까지 가능. 노드 기반 컨테이너가 다 이 양방향 반복자로 접근함.: ++, --
5. 임의 접근 방복자: []까지 있어서 임의 접근이 가능함. vector같은 배열 기반이 이걸 가지고있음. : ++,--,[] 

4,5번이 가장 중요하고, 4,5가 연산자 오버로딩 개수가 가장 많음. (고도화 되어있다고 표현함) 
 
그럼 연관 컨테이너중에서 유일하게 []가 있는 map은 무슨 반복자를쓸까? => 양방향 반복자를 쓴다. 
	일단 노드 기반이니까 ! 
	[]가 된다해도 이건 오버로딩해놓은거고, 실제로는 ++, --로 움직이는 것. 
	그냥 노드 기반은 무조건 양방향 반복자고, 배열 기반은 임의 접근 반복자라고 생각하면됨

반복자 앞에도 const붙일 수 있다. 

*vec.begin()으로 하면 vec[0]의 실제 값을 얻을수있다. 
포인터랑 똑같이 쓰지만 포인터가 절대 아님 *는 오버로딩된 연산자임

-- 이것저것 된다는거 보여주기 
vector<int>::iterator iter = vec.being()'
iter++;
iter--;

iter != vec.end()

cout << *iter <<endl;

== 

vector<int> vec;// 아무것도 없는상태에서 
vec.begin() == vec.end인가?	 => 그렇다. 
원소가 하나 들어가면 다르다. 
왜 > end는 마지막원소의 "한칸 뒷공간"이다. 마지막 원소가 아니라. 그래서 안에 아무것도 없으면 뒷공간을 가리킬 이유역시 없기 때문에 같은거고, 
하나라도 있으면 그 뒤에 빈공간을 가리켜야해서 다른것. ㄴ

==
vec 에 10,20,30,40,50 넣고, 
vecotr<int>::iterator iter = vec.begin()

iter+=2;

vec.insert(iter, 300);	//하면 중간에 넣을수는있다. 
그러나 중간삽입을하면 시간효율이 좋지 않다. 예를들어 4개 원소가 있는데 하나 추가하면 카파시티가 6으로 늘어남.(vs code정책)
근데 중간삽입하면 심지어 몇몇애들은 뒤로 다 밀어야함. 그래서 시간효율이 떨어짐. 

==
백터 안에 10,20,30,40,50 넣고, 
iter = being()
iter+=2
erase(iter)// 3번째 원소가 삭제됨. 

erase는 삭제된 다음 공간의 iterator를 반환함. 그니까 30을 삭제하면 반환은 40이 있는 iterator가 됨. 

근데 이거 또 

for( vector<int>::iterator iter=being();iter != vector.end(); iter++;) 이렇게 돌릴수도있음.
{
	//. 몬스터 다 보면서 충돌된애를 지운다는 예시 
	if(충돌처리){
		iter = vec.erase(iter);	// 여기서 1번을 삭제하면, iter에는 2번이 반환됨. 근데 for에서 iter++해버리니까 다음에는 2번이 아니라 3번을 검사함 => 징검다리로 검사함. 
			그래서 보통 for문에 끝에 iter++를 안쓴다. 어차피 다음iter를 erase가 가리켜주니가.
			// 즉, for( vector<int>::iterator iter=being();iter != vector.end()) 이렇게 씀
			그리고, erase할때는 delete먼저해서 주소 삭제하고나서 erase로 메모리 해제함. 
				1. safe_delete(*iter);	// 주소 삭제 ( 이거는 백터 안에 타입이 객체 클래스인경우를 말하는거얍
				2. iter = vec.erase(iter);	// 메모리 해제

			근데 보통 이렇게 for문안에 뭘하는지 다 오픈하는 코드 자체가 좋지는 않음. 보통은 stl컨테이너안에 있는 알고리즘과 조건자 등을 사용해서, 실제 동작을 은닉할 수 있는 형태의 코드를 많이 씀. 
		
		cout << (*iter)<<endl;
	}
}


---------------------------------------------
[ vector의 각종 맴버함수 part2 ] 

resize
	사이즈는 줄일수있는데 카파시티는 줄어들지 않는다. 재할당 이슈 없애기 위해 그냥 가지고있는 원소의 크기만 줄임

reserve(5)
	카파시티만 확보하고, 원소는 채우고싶지 않으면 이렇게.	
	대신 resize를 하면 그만큼 0으로 채움. 

	리사이즈 = 0으로 된 원소를 채우면서 확보
	리저브 = 카파시티만 확보

	리저브를 미리 하고 쓰는게 좋음. 
	백터는 지형, 타일을 관리하기 위해 많이 쓰는데, (왜냐 > 인덱스 접근 가능하고, 동적할당도 가능하니까. )
	그 백터의 카파시티를 다 확보해두고, 나중에 원소를 채우는게 좋음.

---------------------------------------------
[알고리즘 stl ]

stl알고리즘: 일반화된 기능을 전여그이 형태로 제공하는 함수 템플릿 집단
조건자: bool타입을 반환하는 함수 또는 함수객체 
	물론, bool말고 void같은 다른 타입을 반환하는 애들도 있는데 대부분bool임. 


==
sort 

vec<in> vec
			

sort(vec.being(), vec.end());	// 정렬을 수행해주는 알고리즘 
	조건자 설정따로 안해주면 디폴트가 오름차순
	
	// 조건자 만들어보기 
	bool Less(int a, int b){	// 물론 이렇게 매번 sort마 들어가는 cpp파일마다 얘를 쓰기가 귀찮으니까 보통 템플릿으로 어디 헤더에 넣어놔도 됨.
	return a < b;					// 근데 이런 기본적인 조건자는 제공하는 헤더가 있음. functional 이라는.. 그냥 less<int>로 써도 됨. 
	}	
	bool Greateint a, int b){
		return a < b;
	}
	sort(vec.being(), vec.end(), Less);	// 이렇게 조건자 내가 넣을수도있음. 
	sort(vec.being(), vec.end(), less<int>);	// 이미 정의되어있는 조건자 사용. 

	sort만들어진거보면
		- 일단 템플릿이고 구조체 템플릿이다, ()를 오버로딩 하고 있다. 
			근데 구조체로 되어있음. 왜? 조건자는 어차피 퍼블릭으로 쓰는거잖아. 구조체는 디폴트가 퍼블릭임. ㅋㅋㅋㅋ 클래스는 디폴트가 프라이빗이고..
	
		걍 한단어 더 안칠려고 구조체로 만듬 ㅋㅋㅋ
	
	소트는 백터, 데큐는 쓸수있지만 list는 쓸 수 없음. 
	sort는 배열기반 알고리즘이기 때문. 
	참고로srot는 퀵정렬임. 

	그래서 list는 맴버 함수로 sort를 소유하고있다. 
	연관 컨테이너는 자동정렬하고 .
==
count_t


// 조건자 함수 템플릿만들기 / 마찬가지로 함수 객체로도 할 수 있음. 
template<typename T>
bool IsOddnum(T number){
	홀수면 true반환
}

// 함수 객체로도 만들어봐. 
struct IsOddNum{
	
}

int result = count_if(vec.begin(), vec.end(), IsOddnum<int>);	// 함수 객체가 아니라 포인터 만든거임! 조건자 넘기는거
이렇게 하면 백터 안에서 홀수인 원소만 카운트함. 1,4,6,7 이렇ㄱ ㅔ있으면 2 반환함. 

==
for - which

vector<int*> vecPtr;

struct delete{
	template<typename T>	// 이건 조건자이지만 bool 반환할 필요없는 애니까 그냥 void로 함. (이것도 조건자라고 하나)
	void operator() (T& tremp){	//	이거 T나 T*가 아니라 &여야하는거 알지?
		if(temp)
			delte temp;
			temp = nullptr
	}
}

for(int i=0;i<10;i++) vecPtr.pushback(new int);
for_each(vecPtr.begin(), vecPtr.end(), delete());	//delete는 만들어놓은 거임
	// 정해준 레인지안의 모든원소를 순회하면서 delete 적용

== 
find_if

*/

#include "stdafx.h"
using namespace std;

int main() {

}