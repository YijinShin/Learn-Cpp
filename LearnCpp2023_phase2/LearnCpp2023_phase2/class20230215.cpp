/* 
* 전역변수는 앞에 g_를 붙이자.
-------------------------------------------------------------------------------------------------------------------
* [ extern ]
main.cpp파일에 int g_iNumber = 10; 를 선언하자	// 전역 변수 
(Class.h)클래스 안에서 맴버 함수를 하나 선언하고, 그 함수 내에서 전역변수로 선언되어있는 g_iNumber를 출력해보자.
만약 맴버 함수를 Class.cpp파일에 선언하면, 당연히 문제가된다. 같은 파일이 아니면 해당 전역변수는 사용이 불가능하다. 
만약 Class.cpp에도 같은 전역변수를 선언하면 > 메인에서 선언한 부분에서 오류가 난다. (재정의했다고)

전역변수를 하나만 만들고, 서로 다른 .cpp 파일이 해당 전역변수를 사용하고싶으면 사용하려는 .cpp파일 에 앞에 extern을 붙여서 해당 cpp파일한테 알려주면된다. 
	// class.cpp
		extern int g_iNumber;	// 여기는 초기화 하면안됨. 이건 그냥 전방선언마냥 g_iNumber가 존재한다는 것을 알려만 주는 것이다. 
	// main.cpp
		int g_iNumber = 10;	//초기화는 여기서 하는거고
전역함수도 이렇게 할 수는 있긴한데.. 이렇게 거의 안씀. 

근데 어쨌든 이거 필요할 때 마다 다 돌다아니면서 exteren 하고 다니는건 아주 귀찮음. 
그래서 보통 stdfx.h에다가 exturn int g_iNumber; 이렇게 해버리고, 나머지 cpp에서는 저 헤더파일을 include해서 많이 쓴다. 
-------------------------------------------------------------------------------------------------------------------
* [ friend ]
//player class
{
private: 
	int X = 100;
	int Y = 100;
public:
	void Display(){cout << X<<","<<Y;}
}
//monster class
{
private:
	Player* player;
public:
	void Init() {player = new Player;}
	void Draw(){
		cout << "Player:"<<X<<","<<Y<<end;	// 몬스터에서는 플레이어 정보도 출력하고싶어함. 근데 이거 불가능하잖아. 왜냐, X,Y는 private이니까. 
											// friend를 해버리면 사용가능 
	}
}


이렇게 두 클래스가 있다고 해보자. 

Player클래스에 이렇게 friend선언해버리면 해당 함수나 클래스는 Player의 모든 맴버를(private, public)마음대로 사용할 수 있음.)
friend void CMonster::Draw(void)	// 특정 클래스의, 특정 함수만 친구로 간주
friend class CMonster	// 특정 클래스 전체를 친구로 간주

friend는 은닉화를 깨뜨림. 근데 ㅋㅋㅋ 돎아가면 그만이랭 

-------------------------------------------------------------------------------------------------------------------
* [ 상속 ]
- 부모 클래스 / 자녀 클래스

class 자식클래스명: 접근제어지시자 부모클래스명{
	...
}
접근제어지시자 >> 거의 public, protected을 쓴다. private은 잘 안씀.  
				
				private같은건 오로지 부모 클래스명을 자료형으로만 제공하겠다는 거임. 
				부모의 맴버는 아예 사용못함. 전방선언이랑 비슷한건가?

				protected:	자식한테만 접근 허용함. 근데 자식이 아닌 다른 클래스에게는 허용안함. 
							부모- 자식 에서는거의 protected로 접근을 허용한다. 
							부모가 자식에게 접근 허가를 해줄대는 protected쓰기!! 반드시
							상속 받아도 자식이 부모의 private은 못씀. 
							근데 부모의 protected는 쓸수있음.

부모와 자식에 이름과 타입이 똑같은 맴버 변수가 있으면 어떻게 될까?
=> 같은 이름의 변수라도 서로 다른 애들임.
   이 경우, 자식입장에선 자식의 맴버 변수가 우선권을 가진다. 
   똑같이 int m_iA가 있으면 자식 맴버 함수에서 cout << m_iA하면 자식꺼가 불림. 
   부모꺼를 부를거면 namespace쓰면됨 cout << Parent::m_iA 이렇게 부모클래스명붙이면 부모꺼 부를수있음

생성자, 소멸자 
- 생성자 소멸자도 접근제어지시자 붙일수잇음. 
  생성자, 소멸자도 protected로 하면 자식외에, 외부에서는 부모클래스 생성이 불가능함. 

-자식 객체 생성, 소멸하면 
	[ 메모리 할당 - 부모 생성자 - 자식 생성자 - 자식소멸자 - 부모소멸자 - 메모리 반환 ]이렇게 진행됨.
	이게 자식 클래스 생성, 소멸 순서. 이게 만족되어야함. 


- 자식, 부모 모두 디폴트 생성자를 쓰는거면 상관없는데, 그게 아니면 
  Child(): Parnet(param 넘길거있음 넘기기){ ... } 이렇게 하면 됨.

- 상속받은 자식의 크기 확인해보기 (ok)

- 상속할거면 자식클래스 파일에 부모클래스의 해더파일 넣어야함. (전방선언이 아니라!) 전방선언은 함수나 맴버에 대한 호출 권한은 없는겨! 그냥 자료형만 알려주는거지 (ok)

부모는 자식꺼 못씀 당연함 부모는 자식 자료형을 모르니까 => 이걸 사용가능하게 하려는 문법이 다형성 이게 아마 버추얼 함수에 함수 오버라이딩 이야기인듯 
*/

#include "stdafx.h"
using namespace std;

class FieldObject {
private:
public:
	FieldObject();
	~FieldObject();
};

class CPlayer {
private:
public:
	CPlayer();
	~CPlayer();
};

class CMonster {
private:
public:
	CMonster();
	~CMonster();
};



int main() {

}

/*
과제
textRPG 상속으로 바꿔보기 

*/