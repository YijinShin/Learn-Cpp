/*
* 템플릿 부분 특수화 배움
* 템플릿 선언이랑 몸체 구현 따로 할 수 있음. 선언은 헤드에 하고, 정의는 cpp에. 
	근데 저렇게 할거면 typename T를 정의부에서는 알 수 없음. T라는 키워드의 유효성이 사라지는거임. (T는 그 바로 밑 {}까지만 유효함)
	그래서 분리해서 하려면 정의부에도 <typename T>를 적어야만한다.
	그리고 CObj<T>::Func()이렇게 다 타입 네임 명시해줘야한다. 

	결론적으로 좀 코드가 복잡해짐
	그래서 대부분 템플릿은 인라인화 되는 정도의 적은 코드를 -> 헤더 파일안에 정의해서 끝내버림. 따로 안나누고 

함수 템플릿으로 만든 static메모리 공간은 해당 템플릿 인스턴스 끼리 공유됨
	단, 같은 타입의 함수 템플릿 인스턴스끼리만 공유됨. 
==================================================================================================

[ stl 컨테이너 ]
(컨테이너 종류 많긴한데 여기서는 몇개 안배울거임 나머지는 알아서 겅부하셈)

STL : 표준 템플리 라이브러리 
C++에서 제공하는 라이브러리의 일종으로 프로그래밍에 필요한 자료 구조 및 알고리즘을 템플릿화 하여 제공

STL구성요소 4가지
	- 컨테이너: 데이터를 저장하는 객체, 즉, 자료구조를 구현한 객체를 뜻함
			클래스 템플릿으로 구현되어있음. 
		
			컨테이너 분류기준 2가지 

			- 원소 배치 방법에 따른 분류 기준으로나누면 아래 두 항목으로 나눌 수 있음. 
		
				표준 시퀀스 컨테이너:vector, list,  deque
				표준 연관 컨테이너:set ,multiset, map, multimap

			- 메모리 구성 방식에 따른 분류 기준으로 나누면 아래 두 항목으로 나눌 수 잇ㅇ므.
		
				배열기반의 컨테이너: vector, deque
				노드 기반 컨테이너: list, map, multiset, multimap, set

				선형적이며 노드기반인 컨테이너 설명하세요..뭐 이따구로 물어보기도 함 (list) 엿같은거 
				컨테이너간의 비교질문 많이함. vector와 list의 차이를 말해봐라 
		
			- 컨테이너 어뎁터: 기존 컨테이너의 기능 중 일부 기능만을 사용 가능항하며, 기능 제한이나 기능이 변형되어 있ㅇ
				queue, priority queue, stack 
		
			- 근사 컨테이너: 템플릿으로서 완벽한 기능을 갖추지 못한 상태 
				stirng, wstring 
		
	- 알고리즘: 함수 템플릿으로 만들어져있음. 컨테이너 내에서 정렬, 삭제, 탐색 등을 해결하는 일반화된 방법을 제공하는 함수 템플릿
		대부분의 알고리즘 함수 템플릿은 특정 컨테이너의 멤버가 아니라 전역의 상태로 작성되어있다. 
		일반화 프로그래밍을 위해 캡슐화를 조금 벗겨내고 전역의 상태로 작성한것.
		#include <algorithm>해야함.

	- 함수 객체
		알고리즘 중에 sort(begin, end, Functor)이런게 있다. 이거 functor 함수 객체 알지?


	- 반복자 (iterator)
		포인터와 비슷하지만 포인터가 아님!
		컨테이너에 저장한 데이터에(원소들에) 접근할 수 있는 '객체'이다.
		*를 써서 접근하기 때문에 포인터로 착각할수있는데 포인터 아니다 .
		컨테이너에 포함된 원ㅅ들에 접근하여 읽기와 쓰기를 수행하기 위한 객체, 포인터와 동작이 유사하지만 절대 포인터가 아니다. 

	[begin, end )	반계구간


백터
	- 동적 배열을 기반으로 하는 컨테이너. 
	- 중간 삽입은 시간복잡도가 별로. 용이하지 않다.
	- 맨 뒤 삽입은 상수 시간 복잡도를 가진다. 
	- 배열크기 넘어가면 >> 다시 동적할당함. (기존 배열보다 더 큰 배열 확보하고 복사하고 기존배열 날림)
		그러니까 계속해서 배열의 범위를 넘어가는 형태의 원소 추가를 하면 속도저하됨. 
		(메모리 재 할당에 따른 속도저하) 백터의 단점 
	- 백터의 원소를 삭제해도 원래 존쟀던 원소의 메모리 공간은 남아있는다. (pop_back의 문제점. earase나 이런거 써야할듯) 
		
리스트
	- 여기저기에 흩뿌려져있는 데이터들을 한번에 묶어서 관리하겠다 이거임
	배열은 메모리 자체가 바로 이어서 할당받는데
	리스트는 실제 데이터가 메모리 여기저기 흩뿌려져잇어도 "리스트"라는 구조로 관리하겠다 이거임 
	삽입 삭제는 백터보다 용이하다. 
*/

#include "stdafx.h"
#include <vector>
using namespace std;

/* 함수 template */
template <typename T>
T Add2(T a, T b);

/* 클래스 template*/
template <typename T>
class CTest {
public:
	T Add(T a, T b);
};

using namespace std;

int main() {
	//vector<int> v(5, 2);
	vector<int> v;
	vector<int>::iterator iter;
	cout << sizeof(iter) << endl;
	for (int i = 0; i < 10; i++) {
		v.push_back(1);
		cout << i << ":" << v.capacity()<< "," << v.size() << endl;
	}
}

/* 같은 cpp파일 내에서는 이렇게 가능 */
template <typename T>
T Add2(T a, T b) {
	return a + b;
}

/* 다른 파일에 정의부를 구현하려면 앞에 클래스 이름, 타입 다 붙여야함
	근데 이렇게 하는 것 자체가 굉장히 코드를 복잡하게 만드다. 애초에 템플릿으로 쓰는 함수들은 대부분 인라인화를 노리고 쓰는 경우가 많기 때문에 
	그냥 클래스 템플릿 안에서 선언 + 정의 다 해버리는 경우가 많다. */

template<typename T>
T CTest<T>::Add(T a, T b) {
	return a + b;
}