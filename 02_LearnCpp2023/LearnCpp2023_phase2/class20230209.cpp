/* 
-과제 피드백-------------------------------------------------------------------------

* 클래스
- player, 사냥터, 몬스터, 메인게임

* 보통 맴버함수 Release()는 소멸자에서 호출함.
* 추가 > 클래스 마법사 쓰면 알아ㅓㅅ h, cpp만들어줌. 
* 헤더에 쓴 함수 선언을 잡고 ctrl+. 하면 cpp에 알아서 만들어줌
* 메모리 반환은 함수 메크로로 정의하고

* Define.h 
	- 플레이어 정보가 들어있는 struct만들기( hp, 공격력, 이름) 

* 초록색 = 는 연산자 오버로딩임. 진짜 대입연산자는 아님. 

* Player class
	- 여기에는 아예 맴버 변수자체가 struct말고는 안둠. (은닉화 때문인듯. 보호하려고, 폐쇠적으로)
	- 직업선택함수 > 직업, hp, 공격력 넣어줌. 
	- Render()함수:state출력 //이게 약간 눈에 보이게 하는 동작 들어있는 함수들을 이렇게 이름붙이는듯
	- 생성자에서 memset()으로 플레이어 sturct를 0으로 초기화 시킴. 
	
* string 컨테이너는 컴파일러마다 할당하는 크기가 다를 수 있다. 보통 24바이트

* 메인게임 객체는 별로 용량이 안큰데(맴버가 거의다 함수라서)
	플레이어는 sturct가 용량이 좀있어서 동적할당으로 선언하는게 좋다. 플레이어를 그냥 선언하면 struct크기정도 가는데, 플레이어 포인터를선언하면 4바이트면되니까. 
	그래서 메인게임 객체는 main()에서 그냥 선언해버리고, 플레이어는 동적할당하는것이다.
	어차피 heap에서 할당해야하는것아닌가? => 맞다. 그래도 구지 컴파일 타임에 미리 잡아둘필요가 없다. 미리 잡아두면 그 메모리를 점유하고있어야한다는 것. 
												그래서 동적할당하는것. 
	어쨌든결론은 player객체는 MainGame 클래스안에서 맴버 변수로 플레이어 포인터 선언해서, 플레이어를 만들어쓰기 

* maingmae의 Initialize()에서, 만약 플렝이어 포인터가 null이면 만들고, 아니면 안하기 
	플ㄹ에이어 생성하고, 이후에 직업선택까지 여기서 호출하네

* Update()에서 처음에 init하고 > 그 게임 메인 스트림 코드(사냥, 종료) 넣음. 
* 플레이어 메모리 반환은 진짜 찐 게임 종료시에. 죽는다고 하는건 x 
* 소멸자 안에 release()가 있고, 그 안에 메모리 반환 함수 메크로를 넣어둘거임. 그러니까 자연스럽게 플레이어 객체 사라지면 알아서 release되는거임. 


* stirng str = "aaa";	// 이건 문자열 맨 앞 포인터변수(char*)에 const char*을 넣으려는 시도임. 
 그니까 당연히 대입연산자로는 저게 불가능함. 그래서 이떄의 =는 초록색이고, 연산자 오버로딩 된거임. 

 그 메모리 해제 메크로할때 if(p)를 붙임. 이거는 아마 이미 p가 nullptr이면 댕글링포인터도 아니고 뭐 초기화할필요가없어서 그런듯. 
 if(p) {delete p; p = nullptr}

 클래스 동적할당할때 Ctest* ct1 = new Ctest(0)하면 안에 쓰레기 안들어가도록 해주나봄. 이거 한번 확인 ㄱ => 아님~! 

 * 사냥터 클래스 > 만약 플레이어가 사냥 선택한 뒤에 동적할당으로 생성하면 매번 사냥터 선택할때마다 할당해야하고, 마을로 돌아갈때마다 해제해야함. 
	사냥터를 선택하면 사냥터클래스의 update()를 부르도록짜는게 좋다. 
	결론은 메인게임의 private에 필드 포인터 변수를 선언해두기 player처럼
	그리고 걍 사냥터를 maingame의 initialize에서 만들어주기 player처럼.(근데 뭐 상관없다.. 하고싶은대로 하기)
	메모리 해제도 걍 게임종료시하기 

* 필드 클래스에 플레이어객체 대려오기
	-> 필드 클래스도 player.h include하고, 플레이어 포인터 변수만들어서
	-> mainclass에서 필드 클래스 호출할때 setpPlayer()함수 써서 mainGame클래스의 플레이어 주소 넘겨주기 

* 몬스터는 필드 클래스에 포인터 변수만 만들어두고, 난도 선택한 후에 몬스터 동적할당함. (매개변수로 등급 주고)

수업진도----------------------------------------------------------------
객체 배열 (근데 걍 배열임..뭐 더 특별할건 없음..)

* 클래스도 배열로 선언할 수 잇따. [객체의 배열]
* n길이의 클래스 배열을 만들면 생성자, 소멸자 다 n번씩 불린다.
* 동적할당도 마찬가지.
* 
* 당연히 객체 포인터 배열도 있음 걍 class* obj[3] .. 포인터배열임 ㅋㅋㅋㅋㅋ 


*/


