/*

* 클래스 상호참조 발생
두 클래스가, 서로를 #include하고 있으면 무한루프에 빠져버리는거임. 헤더가서 코드 싹 긁어오려고했더니 거기에 또 내가있고..뭐 그런거
상호참조를 해결하면서, A에게 B자료형을 알려주고싶다면 -> [ 전방선언 ] 을 통해 알려줄 수 있음. #include 안하고. 

문제 1. 
근데 이렇게 해도 A, B가 상호 참조를 하고있다면 어쨌든 문제는 여전히 해결되지 않는다. => 객체 생성을 위해서는 객체의 크기를 알고 우선 메모리에 할당을 해야하는데
전방선언은 걍 자료형의 유무만 알려주는거고, 실제 그 자료형의 크기는 모름. => 그래서 메모리 할당을 못함. 

문제 2. 
설령 메모리 크기를 안다고해도 생성자를 호출못해서 객체생성이 불가능함. 
* 전방선언 = 자료형의 유무만 알려주는것. 그 안에 무슨 맴버가 있는지는 알 수 없다. 그래서 맴버 함수 호출이 불가능함 == 생성자 호출도 불가능함. 
			그래서 전방선언만 해놓고 그 클래스 객체 만들면 => 객체 생성이 안됨.								// study_44_55.cpp에 나옴. 

해결해야하할 문제가 2개인거임. 

해결1. 
A가 B를 포인터 변수로 선언하면됨. B* m_b이런식으로. => 그러면 일단 메모리에 할당할 그 변수 크기는 나옴. (포인터니까 4또는8)
근데 저 전방선언을 A.h에서만 하면 A.cpp는 모른다. 


* 전방선언을 쓰는 것은 => 상호참조가 발생했을 때 쓴다.(두 객체가 서로를 필요로하는상황)
	사용시 규칙
	1. 헤더파일에는 전방선언하고, 멤버 변수로는 포인터 타입으로 선언
	2. cpp에 포함하고자 하는 헤더파일을 포함시킨다.
	둘중에 한쪽만 전방선언을해도 문제 없음.
	대신 양쪽의 생성자에서 서로를 동적할당하면 또 문제가 생김. 
	그래서 initialize를 생성자에서 호출하지는 않는것임. release는 소멸자에서 호출하긴해도 

[ 디폴트 대입연산자, explicit ]------------------------------------------------------------------------------------------------
객체 생성되면 눈에 보이지 않는 4가지가 같이 생기는데
- 디폴트 생성자
- 디폴트 복사 생성자
- 디폴트 소멸자
- 디폴트 대입연산자=> 애때문에 CObj obj = 100; 이따구로해도 동작함. 
		obj(100)
		obj = 100
		obj(100,200)
		obj = {100,200}

	디폴트 대입 연산자 => 컴파일러가 스스로 판단해서 대입연산을 할때 임시적인 객체를 하나 만들어야하는데, 그걸 디폴트 대입연산자, 너가 만들어서 해 라고 한것 -> 이걸 묵시적형변환이라고함. 
	그래서 이런 묵시적형변환을 못하게 하고싶으면 생성자 앞에 [ explicit ]을 쓰면 디폴트 대입연산자가 맘대로 생성단계를 실행할 수 없음. 
	컴파일러에 의해 자동형변환되는것을 막기위한 키워드 

[ 캡슐화 ]-------------------------------------------------------------------------------------------------
 
 --
 클래스의 특성으로 추상화 말하면 미친놈이다. 



*/
#include "stdafx.h"
using namespace std;

class Obj {
public:
	int* a;
	int b;
	void Display() { cout << *a << "," << b << endl; }
	/*
	Obj& operator= (const Obj& refObj) {
		a = refObj.a;
		b = refObj.b;
		cout << " = 오버로딩 " << endl;
		return *this;
	}

	Obj& operator= (int a) {
		cout << " = 오버로딩 " << endl;
		return *this;
	}

	Obj(const Obj& ref) {
		// 얕은 복사 
			//a = ref.a;
			//b = ref.b;
		// 깊은 복사 
			// int newData = *ref.a 이렇게 하고 newData 주소값을 넘겨주면 당연히 이 함수 끝나면 stack 메모리 해제되면서 쓰레기값됨 .
		int* newData = new int;
		*newData = *ref.a;
		a = newData;
		b = ref.b;
		cout << " 복사생성자 오버로딩" << endl;
	}
	*/
	
	Obj(int* _a, int _b) {
		a = _a;
		b = _b;

		cout << "생성자 오버로딩" << endl;
	}
	
	//Obj() {
	//	a = nullptr;
	//	b = 20;
	//	cout << "생성자 오버로딩2";
	//}
	
	//Obj(const Obj& obj) {
	//	cout << "복사 생성자 오버로딩" << endl;
	//}

	
	
};


#include "stdafx.h"

int main() {
	/*

	// 디폴트 복사 생성자 
	/*
	{
		int num = 10;
		int num2 = 20;
		Obj obj1 = { &num, 200 };	// 위에 복사 생성자 오버로딩을 한 이상, 즉, 하나라도 생성자를 오버로딩한 이상 디폴트 생성자가 생기지 않음. 
		Obj obj2 = obj1;	// 이렇게 선언시 바로 = 쓰면 디폴트 대입연산자가 아니라 복사 생성자가 쓰임 
		// Obj obj2(obj1); 이거 위에 구문이랑 같다. 둘다 복사 생성자쓰는 구문임. 

		obj1.Display();
		obj2.Display();

		cout << endl;

		//obj1.a = &num2;	// 이렇게 하면 obj1.a가 가진 주소값 자체가 바뀌면서 obj1과 obj2가 서로 다른 값을 참조하게되는게 맞다. 
		*obj1.a = num2;	// 이렇게 하면 obj1.a와 obj2.a가 지금 같은 주소값을 저장하고있는데, 그 주소값이 참조하는 값만 바꾸는거라 한쪽 바뀌면 다같이 바뀐다. 

		obj1.Display();
		obj2.Display();
	}
	
	// 오버로딩된 대입연산자 
	{
		int data = 10;

		Obj obj1 = { &data, 100 };	// 오버로딩된 생성자 쓰기 ( 오버로딩된 대입연산자를 쓰는 것이 아니다.)
		Obj obj2 = obj1;

		Obj obj3(&data, 200);	//
		//obj2 =10;
		obj1 = obj2;	// 오버로딩된 대입연산자 사용 ( 오버로딩 안했으면 그냥 디폴트 대입연산자 사용됨)


	
	}
	cout << endl;
	// 디폴트 대입연산자 
	{
		int data = 10;
		int data2 = 20;
		Obj obj1 = { &data, 100 };	// 오버로딩된 생성자 쓰기 ( 내가 오버로딩한 대입연산자를 쓰는 것이 아니다.)
		Obj obj2 = { &data2, 200 };		// 오버로딩된 복사 생성자 쓰기 

		obj1 = obj2;
		*obj2.a = 1000;
		obj1.Display();
		obj2.Display();
	}
	
	*/

	{
		int num = 10;
		//Obj t2;
		Obj t4(&num, 20);


		Obj t3 = t1;

		t2 = t1;


		cout << endl;
		//Obj t2 = t1;

	}
	
}

