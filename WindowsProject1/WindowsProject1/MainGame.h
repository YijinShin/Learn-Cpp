#pragma once
#include "Define.h"

class CMainGame
{
private:
	HDC m_DC;
public:
	CMainGame();
	~CMainGame();
	void Initialize();
	void Update();
	void Render();
	void Release();
};

/* 
[플레이어 만들기]------------------------------------
Obj, player:obj 이렇게 상속해서 만들어주기 
순수 가상 함수 만들거라 =0 에 쓸 퓨어라는 메크로도 만듬. 
그리기 함수 Render는 DC를 매개변수로 받음. 한 화면에 그려야하니까 같은 DC를 써야함. 

원래 우리가 사각형 그릴떄 왼쪽 끝점, 오른쪽 아래점 으로그렸잖아.
그러면 사각형의 중점을 알고, 사각형 가로, 세로 알면 좌표 구해서 그릴 수 있음. 
이런 사각형을 만들기 위해 디파인에 구조체 만들거임.
typeef struct tagInfo{
	float fx; // 중점 x
		float fy; // 중점 x
	float fcx; // 가로길이 x
	float fcy; // 가로길이 x
}INFO;

이걸 obj에서 맴버로 씀. 
구조체 초기화할떄 zeromemory라는 메크로 함수 씀. memset대신에. 두개 차이 있으니까 공부해두기 

플레이어 생성할떄 초기 위치를 initialize()에서 지정함. 
렌더에서는 rectangle이라는 함수를 사용해야하는데, 그 좌표는 update()에서 연산함. 
rander()에서는 딱 그리는것만. (update에서 update_rect()함수를호출해서, 거기서 연산함) 
LONG은 형변환한것. 

__super:: 최상위 클래스를 접근할때. 부모클래스의 맴버 함수 호출해라를 명시적으로 할때 __super::Update_Rect()이렇게 하면 
명확하게 부모의, Update_Rect()를 호출하라고 명시적 표시가 가능. 

플레이어 움직임 -> 지금 외부 파일에서 시도하려고 하기 때문에 윈도우에서 제공하는 함수를 사용해서 강제적으로 메세지를 발생시켜야한다. 
	1. getakeystate
		함수가 호출될때 반환값이 4가지인데, 반환값에 따라 의미가있음. 
		0x000 : 이전에 누른적이 없고, 호출 시점도 눌려있지 않은 상태 이런식으로 4개 있음. 표 참고해 
		일반적으로 0x8000을 사용함.이건 당장 누른키 인식. 8001은 꾹 누르고 있는 상태
		근데 이것도 사실 정교한 키입력을 처리하지 못해서 나중에는 따로 key 입력을 메니지하는 클래스를 작성해야함.

	2. getkeystste

key_input()함수: 매 프레임마다 키 눌렸는지 확인해야하니까 업데이트에서 호출함. 
upate_rect는 제일 마지막에 호출되어야함. 위에서 각종 데이터가 다 호출된 후에, 그 데이터를 기반으로 좌표값을 다시 계산하는 것이기때문

key_input(){
	if(getakeystate(VK_RIGHT)) { . . . }	// 오른쪽이면.. 이런식으로. 작성하면됨. 
}
우리는 한번 툭 눌러도 실제 키 입력 메세지는 엄청 많이 들어감. update()는 윈도우의 메인함수에서 불리는데, 그게 엄청 빠른 주기로 실행되서 그런거임. 
그래서 여까지만 하면 사각형이 쏜쌀같이 확 지나감. 
=> update와 렌더를 호출하는 주기를 맞춰줘야함 == 프레임을 제한해야함. 초당 업뎃 횟수를 제한하는거임. 

// 최적화를 하려면 그리기를 최소화해야함. 이건 앞으로 우리가 코딩하면서 항상 고민할 것. 

DWORD : 언사인드 롱. 시간값을 저장할거라 이거 쓸거임. 
DWORD dwTime = GEtTickDoun(): 운영체제가 시작된 후로 흐른 시간을 정수 형태로 반환. 
	1/1000초의 정수 값을 반환함. 
	api이후로 안씀. 정밀함이 떨어지기 때문에. 1초 이하 단위의 시간값을 정밀하게 못쓴대
	그리고 컴퓨터 성능에 따라 오차가 큼. 그냥.. api라서 쓰는거임. 
돌아와서
업뎃, 렌더 호출할때 조건을 주는거임. 
if(dwTime+10 < GetTickCount() ) { 
	업뎃하기 ,
	렌더하기 , 
	dwTime = GetTickcount();	// 이거 초기화 꼭 하기 } 이런식으로. 
여기까지 하면 움직임은 괜찮은데 그래도 잔상남음. => invalidate는 화면을 갱신하는 함수.
	타이머가 없으면 못쓰는데, 이걸 어케 해결할까
	Rander에서 Rectangle을 그려서 덮을 수 있다. 즉, 배경에 거대한 네모를 같이 계속그리기 
		이런 기법을 더블 버퍼링이라고함. 어제도 말했지만 api는 뭘 지울 수는 없음.
	근데 그릴게 많아지면 화면이 순간적으로 깜빡거림. 이걸 해결하기 위해 더블 버퍼링이라는 기법을 쓰는거임
---------------------------------------------------
[총알 발사하기 ]
bullet 클래스 하나 만들기 

총알이 생성되는 곳 => 플레이어의 key_input()안에서. 왜? 스페이스 눌러야 생ㅅ성되는거니까 
if(GetAsysncKeyState(VK_SPACE)){ ... } // 여기 안에 
총알 좌표는 플레이어의 중심점. 
플레이어가 움직이면 총알 생성 위치도 바뀌므로, 총알클래스에 Set_Pos() 함수를 만들고, 위치 받아오는거 만들기 
총알크기, 스피드는 CBullet의 init에서 

총알 생성위치가 플레이어라 플레이어 클래스의 맴버로 둔다 치자 그럼 총알 업뎃을 MainGame에서 불러오는게 좀 힘들다. 
CBullet의 랜더, 업데이트를 어디서 호출할것인가. => MainGame에서 해야함
그래서 
총알 리스트를 MainGame()에서 포인터로 객체 생성하고, 업뎃이랑 이런건 다 maingmae에서 함. 
그럼 총알이 리스트에 들어가는, 그 생성은 어케해야할까 
플레이어의 맴버로 list<bullet*>*를 만들고, maingame에 있는 총알 리스트를 플레이어한테 포인터 전달하기 
플레이어에서는 그 주소만 아는 리스트에 스페이스 누를때 총알 3개씩 넣어주면되는거임. 

--------------
[wasd로 각 방향으로 총알 한발 나가는거 + 스페이스로 3개 동시에 나가는거]



*/

/* 과제
1. 전체화면이 0,0 800,600 인데
	전체보다 100씩 작은 사각형만들고, 길이 700,500짜리 사각형만들고
	플레이어가 쏘는 총알이 그 사각형을 벗어나면 삭제되도록
	플레이어는 사각형 밖으로.. 나가도 상관은없음. 
2. 몬스터 한마리 만들기(좌우로 움직이는 몬스터)
	몬스터가 작은 사각형끝에 부딫치면 반대쪽으로 움직이기

*/

/*
수업 코드 복습 -> 디폴트 윈도우 기준으로 비슷하게 만들기(따라치지말고)
-> 과제하기 -> 내가 만들고싶은 미니게임 계속 만들기 
*/