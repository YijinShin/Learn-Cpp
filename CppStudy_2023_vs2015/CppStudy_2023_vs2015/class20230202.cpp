#include <iostream>
#define PI 3.14f	// 이게 상수를메크로로	(메크로 상수)
					// 이건 전처리에서 동작하니까 ;가 필요없음. ;는 컴파일타임에 한줄의 끝을 알려주는애임 

// 메크로화 할 대상이 없는 경우 빈 공간으로 처리됨
// 배열 size를 보통 메크로로 많이 선언해둠

// 함수 메크로 (메크로 함수) 
/* 함수 메크로는 함수가 아니다! 그래서 메크로 함수라고 말하긴 좀 그럼
* 이건 단순치환하는 느낌이다.
애초에 등록해두고 쓰는게 아니라 그 즉시 치환하고, 호출해서 쓰고하는게 000코드라고 부름
근데 이렇게 그때그때마다 부르는 경우 속도문제가있을수있다.
그리고 전처리기에 있는 코드는 문법오류가 안잡힘 알아서 찾아야함

장점: 어떤 자료형이든 단순치환 가능 MUL(3.14f)이것도되고 MUL(1)이것도됨. 
	자료형에 따른 별도의 함수들을 재 선언할 필요가없다.
단점: 디버깅이 얿다
	복잡한 함수의 기능을 구현하는 것이 매우 어렵다.
	보통 아주 짧은 연산같은것만 메크로화함

*/
#define MUL(X) X*X	// 이걸 호출하는쪽에 단순치환으로 이 코드를 끼워넣는거임. 
#define MUL2(X) ((X)*(X))	// 이렇게 해야지 의도한대로됨(?) 연산자 우선순위때문에 어쩌구..
#define MUL3(X) (X)*(X)\// ㄷ음줄이 있으면 역슬러쉬 넣는거임. 
+(X)						// 2줄짜리 메크로

#define MUL3(X) (X)*(X)\        	// 근데 이거처럼 \뒤에 공백이 있으면 이거까지 다 메크로 들어감. 그래서 공백 다 없애주는게 좋음.  
+ (X)

// 몇가지..메크로 쓰는데 도움되는것들
#define STRING(A,B) A"의 직업은"B"입니다."	// 이렇게하면만약에 내가 a,b에 string을 전달하려고 할때 ""써야함
#define STRING2(A,B) #A"의 직업은"#B"입니다."// 이렇게하면 A,B에 string넣을 때 ""안써도됨
#define COMBINE(A,B) A##B

using namespace std;

int main() {
	
	/* 파일 함수: fseek()
		[대상 파일 스트림, 이동할 바이트 수, 시작 지점]: 바이트 단위로 프롬프트이동ㅇ
		성공시 0, 실패시 -1
		세번째 매개변수 옵션 :  SEEK_SET, SEEK_CUR, SEEK_END

		ftell() // 현재 지시자 위치 알려주느 함수

		feof() : 파일 지시자가 EOF에 도달했는지 검사하는 함수. 파일 끝인 EOF에 도달한 
	*/
	{

	}

	/* 메크로를 쓰는 경우
	* - 상수값을 메크로로 ( 메크로 상수)
	* - 함수를 메크로로 
	
	전처리기에 문제가잇으면 이게 어디서 문제가 난건지 컴파일타임에는 안알려줌. 전처리기니까 그래서 오류잡기 살짝 어려운감이있음. 그러니까 메크로 선언할때 오류있는지 확인잘하기

	*/
	{
		cout << MUL(10) << endl;
		cout << 2+2*2+2 << endl;
	}
}