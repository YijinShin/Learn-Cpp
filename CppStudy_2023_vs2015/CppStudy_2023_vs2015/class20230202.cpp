#include <iostream>
#define PI 3.14f	// 이게 상수를메크로로	(메크로 상수)
					// 이건 전처리에서 동작하니까 ;가 필요없음. ;는 컴파일타임에 한줄의 끝을 알려주는애임 

// 메크로화 할 대상이 없는 경우 빈 공간으로 처리됨
// 배열 size를 보통 메크로로 많이 선언해둠

// 함수 메크로 (메크로 함수) 
/* 함수 메크로는 함수가 아니다! 그래서 메크로 함수라고 말하긴 좀 그럼
* 이건 단순치환하는 느낌이다.
애초에 등록해두고 쓰는게 아니라 그 즉시 치환하고, 호출해서 쓰고하는게 000코드라고 부름
근데 이렇게 그때그때마다 부르는 경우 속도문제가있을수있다.
그리고 전처리기에 있는 코드는 문법오류가 안잡힘 알아서 찾아야함

장점: 어떤 자료형이든 단순치환 가능 MUL(3.14f)이것도되고 MUL(1)이것도됨. 
	자료형에 따른 별도의 함수들을 재 선언할 필요가없다.
단점: 디버깅이 얿다
	복잡한 함수의 기능을 구현하는 것이 매우 어렵다.
	보통 아주 짧은 연산같은것만 메크로화함

*/
#define MUL(X) X*X	// 이걸 호출하는쪽에 단순치환으로 이 코드를 끼워넣는거임. 
#define MUL2(X) ((X)*(X))	// 이렇게 해야지 의도한대로됨(?) 연산자 우선순위때문에 어쩌구..
#define MUL3(X) (X)*(X)\// ㄷ음줄이 있으면 역슬러쉬 넣는거임. 
+(X)						// 2줄짜리 메크로

#define MUL3(X) (X)*(X)\        	// 근데 이거처럼 \뒤에 공백이 있으면 이거까지 다 메크로 들어감. 그래서 공백 다 없애주는게 좋음.  
+ (X)

// 몇가지..메크로 쓰는데 도움되는것들
#define STRING(A,B) A"의 직업은"B"입니다."	// 이렇게하면만약에 내가 a,b에 string을 전달하려고 할때 ""써야함
#define STRING2(A,B) #A"의 직업은"#B"입니다."// 이렇게하면 A,B에 string넣을 때 ""안써도됨
#define COMBINE(A,B) A##B

// 조건부 컴파일
//#if
//#ifdef
//#ifndef
#if 조건// if문의 시작과 동일한 기능을 가짐
#elif 조건// 
#else 

// 메크로는 같은이름으로 1개이상정의 안됨

using namespace std;

int main() {
	
	/* 파일 함수: fseek()
		[대상 파일 스트림, 이동할 바이트 수, 시작 지점]: 바이트 단위로 프롬프트이동ㅇ
		성공시 0, 실패시 -1
		세번째 매개변수 옵션 :  SEEK_SET, SEEK_CUR, SEEK_END

		ftell() // 현재 지시자 위치 알려주느 함수

		feof() : 파일 지시자가 EOF에 도달했는지 검사하는 함수. 파일 끝인 EOF에 도달한 
	*/
	{

	}

	/* 메크로를 쓰는 경우
	* - 상수값을 메크로로 ( 메크로 상수)
	* - 함수를 메크로로 
	
	전처리기에 문제가잇으면 이게 어디서 문제가 난건지 컴파일타임에는 안알려줌. 전처리기니까 그래서 오류잡기 살짝 어려운감이있음. 그러니까 메크로 선언할때 오류있는지 확인잘하기

	*/
	{
		cout << MUL(10) << endl;
		cout << 2+2*2+2 << endl;
	}

	//----------------------------------------------------------------
	
	/* 레퍼런스 타입
	
	레퍼런스와 포인터의차이.. 걍 둘이 반대 아님?

	포인터의 크기는 4(또는8) 
	레퍼런스는 타입의 크기를 따라감. char&면 1, int&면 4

	심지어 변수만 있고 참조를 안하면
	포인터는어쨌든 할당받았으니까 4인데 ref는 초기화 안했다고 에러남 

	pointer는 운영체제 상황에 따라 크기가 결정됨
	ref는 참조하고자하는 데이터의 크기에 따라 결정됨. 애초에 ref그 자체는 용량이 따로 없음. 
	ref는 주소도 없어. 이건 할당되는 공간 자체가 없다! 
	일종의 별명같은거다.
	자료형이라고 생각할순있지만 변수와는 좀 다르다!

	할튼 ref는 초기화해야만 가능. 
	함수의 매개변수로 ref를 넘기면 ..당연히 필요없겠지만 

	{}안에서의 ref와 함수 매개변수로의 ref의 사용 차이가 있다는거 기억하기

	ref는 포인터와 다르게.. 참조하는 대상을 바꿔도 소용없음 
	거의 상수 포인터 느낌으로 처음에 초기화할때 참조한애만 참조 가능함.

	매개변수로 포인터를 쓰면 call by pointer이고 그냥값만하면 call by value인데, 여기서 pointer가 더 빠름.근데
	그거보다 call bt ref가 더 빠름. 
	c++에서도 ref사용을 적극적으로 권장함

	근데 ref를 사용해서 동적할당은 불가능함. 그래서 포인터를 꼭 써야하는거임.

	ref는 앞으로 많이쓸거임 

	레퍼런스는 lvalue만 허용함 
	근데 rvalue 참조 가능한 (상수값 같은거) ref도 등장함.. 나중에 배울거임
	&10 이런거 말하는거야
	const ref가 붙으면 상수를 참조할수있게 해줌. 대신 const 니까 읽기 전용임. 못씀 
	*/
	{
		int iData = 10;
		int iTemp = 20;
		int& ref = iData;
		ref = iTemp;	// 에러가 나는건 아닌데 이렇게 한다고해서 iTemp를 참조할수는없다. 무조건 iData만 참조하개됨
		ref = 100;	//이거 역시 iData의 값을 바꿈. 
	}


}
