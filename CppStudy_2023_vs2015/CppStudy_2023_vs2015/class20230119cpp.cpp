/*class 2023 01 19

32비트에서는 주소가
0부터 ~ 0xffffffff => 총 4기가
6비트에서는 주소가
16테라까지 사용가능.





int* p = &a;

++p; 이런걸 포인터 연산이라고 함 그러면 0x1에서 0x5가됨. 왜냐 -> int크기ㅏㄱ 4바이트니까 4씩 더해주는게됨
그니까 int a[0] 가 0x1 ~ 0x4까지 차지하고있다고 해
그러면 int* p = &a[0] 
	   ++p; 하면 
	   0x2가 아니라 &a[1]인 0x5가 되는것. 

	   왜냐 -> 타입이 int* 니까!

즉, 포인터 크기는 운영체제 따라가고, 포인터 연산은 선언된 포인터 자료형에 근거해서! 





------------------------------------------------------------------------------------------------
과제!

1. 
자판기함수로 만든거 -> 포인터를 사용하도록 변경하기
뭘 포인터로 할건지는 알아서 

2.

int iDest(10), Src(20);

// 여기 사이에 뭔 함수를 써서 iDest와 Src의 값을 바꿔
	이거 를 함수와, 포인터 사용해서! 구현하기 

voud << iDest << '/t' << iScr // 20,10이 나와야함



*/

