#include <iostream>

using namespace std;

int main() {
	/* 스트림:  소프트웨어인 프로그램과 하드웨어인 기계는 서로 연결되어있지 않은데 이런 상태를 ... 
	 스트림은 단방향성을 띄기 때문에 입, 출력 스트림을 별도로 생성하여 관리해야한다.
	 입력버퍼, 출력버퍼 (이거 옛날에 정리했던거 다시 찾아보기)

	 버퍼의 필요성: 데이터의 송수신의 효율성 떄문에 필요

	 콘솔 표준 입출력의 스트림 종류
	 - stdin: 표준 입력 스트림(기본 키보드 대상)	
	 - stdout: 표준 출력 스트임(기본 모니터 대상)
	 - stderr: 표준 에러 스트림(기본 모니터 대상이지만 우리가 보지 못함)

	 콘솔에 출력을 하건 파일에 출력을하건 출력에는 두가지 모드가있다.
	 - 텍스트모드 ( 텍스트로 출력함)
	 - 바이너리 모드( 2진수 형태로 표현됨)

	 쓸데없는 함수 배울거임 >< (c언어 기반의 함수.. 할튼 오늘 이후로 거의 안쓸거임)
	 ---------------------------------------------------------------------------
	 - 단일문자 출력함수(아스키 코드 한글자 출력) putchar(), fputc()
		 - putchar() : 콘솔입출력에서만 사용가능
		- fputc() :  모든입출력에 사용가능
	- 단일 문자 입력받는 함수
		- getchar(): 이거 엔터도 문자로 먹어서 입력씹힐수있음. 버퍼 비우기 필요
		- fgetc():

	EOF : 파일의 끝을 표현하기 위해 정의해놓은 상수(-1) 
	
	---------------------------------------------------------------------------

	문자열 출력 함수 
	- puts : 출력뒤에 한줄내림 기본제공
	- fputs : 한줄내림 제공안함

	우리가 "개행"이라고 말하는건느 대부분 /n이 아니라 /r/n임. 
	/r/n 사실 개행전에 /r(캐리지리턴)이 붙에있음 이게 앞으로 당기는건데 그래서 aaa << endl; bbb 출력하면
	aaa 
	   bb 이게 아니라
	aaa
	bb 이렇게 앞으로 빈자리 채워서 나오는거임. 

	근데 이 캐리지 리턴은 일반 바이너리 모드에서는 있으면 문제가 생길수있음. 텍스트모드이면몰라도
	(음원 파일같은건 앞으로 댕겨버리면 큰일남) 그래서 fputs는 자동 개행(/r포함)을 제공하지 않느거임. 그런 함수가 필요한 경우가 있다는 것.


	문자열 입력함수
	-get_s : cout과 다르게 공백도 인정함. 그래도 엔터는 안읽음 // 사이즈가 초과되면 오류가 발생함.
	-fgets : 스페이스바 인정, 엔터 인정안함  // 사이즈 초과해도 fgets는 설정한 사이즈만큼 읽어오고, NULL문자 붙임
	
	--------------------------------------------------------------------------------
	버퍼 비우기
	출력버퍼 비우기 : fflush(stdout); 
		자주 사용하지는 않음
	입력버퍼 비우기: 
	 
	 
	--------------------------------------------------------------------------
	
	스트림 생성 -> 파일 쓰기. 파일 읽기-> 스트림소멸

	절대경로 :
	상대경로: 프로젝트 파일 기준임 이전단계로이동하는 그거 ../ 이런거 쓰는거 
	vcxproj = 프로젝트 파일 
	

	// 스트림생성  ( = 파일을 개방하다 라고도 함)
	- fopen_s() : c 언어 함수 / 
	*/
	// 
	{
		FILE* pSaveFile = nullptr;

		errno_t err = fopen_s(&pSaveFile, "../Data/TestFile1.txt", "wt");// 파일 개방	// 모드 이거 rwa말고 t, b이것도 있음 t가 택스트모드ㅡ, b가 바이너리 모드 / wt면 쓰기 전용 텍스트모드 
		if (0 == err) {
			fputs("hello world", pSaveFile);	// 이건 파일에 쓰는거니까 fputs를 쓰는거임 
			cout << "저장성공" << endl;
		}
		else {
			cout << "그런 ㅍ일은 없습니다."<<endl;
		}

		// 개방했으니 반드시 소멸시켜야함
		fclose(pSaveFile);
	}
	
	{
		// 바이너리모드 입출력 
		FILE* pSaveFile = nullptr;
		int arr[5] = { 1,2,3,4,5 };
		errno_t err = fopen_s(&pSaveFile, "../Data/TestFile2.txt", "wb");// 파일 개방	// 모드 이거 rwa말고 t, b이것도 있음 t가 택스트모드ㅡ, b가 바이너리 모드 / wt면 쓰기 전용 텍스트모드 
		if (0 == err) {
			fputs("hello world", pSaveFile);	// 이건 파일에 쓰는거니까 fputs를 쓰는거임 
			cout << "저장성공" << endl;
		}
		else {
			cout << "그런 ㅍ일은 없습니다." << endl;
		}

		// 개방했으니 반드시 소멸시켜야함
		fclose(pSaveFile);
	}

}

/*
test rpg 세이브 만들기
- 구조체 저장할때 문자열 저장할때 string쓰는건 에러날수있음
저장은 괜찮은데 읽을때가 문제 생김. 왜냐 c++의 문법이라 c함수는 읽어오기 어려움. 
구조체 안에 string넣는거는 c++에서도 엄격히 유의하라고 경고하고있음. 
그러니까 그냥 char이 나을듯 

과제2 
시놀로지에 있는 그림 파일입출력을 통해 복사해오기
읽어들인다움에 다른이름으로 저장해라는소리임 복사라고 그 복사 아니라.


*/