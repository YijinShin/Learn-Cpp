/*문자열(?)의 역사

SBCS : 싱글바이트 캐릭터 set 
	아스키코드 문자만 지원하는 문자 시스템 

sbcs이후에 등장한게 

MBCS : 멀티 바이트 캐릭터 셋
	아스키 코드와 유니 코드 겸용하여 지원하는 문자 시스템

이후 등장한게

WBCS L와이드 바이트 캐릭터 셋
	유니 코드를 주로지원하는 문자 시스템


char szName[5] = "jusin";	// 이렇게 하면 오버플로어 컴파일에러나거든? 왜일까

jusin을 임시메모리에 저장하고있다가, 대입연산자를 통해 szName으로 이동시키는거잖아
jusin은 문자열상수 (어쨌든 본질은 상수형태니까(아스키코드))
컴파일러는 임시메모리에 있는 jusin의 길이를 모른다. 
그래서 약속을 하는거임 \0문자를 만나면, 그 문자열이 끝났다고 인식하는 것으로
이렇게 해야 컴파일러가 jusin까지가 한 문자열임을 인식함. 
그래서 jusin을 넣으려면 \0까지 포함해서 총 6사이즈의 공간이 필요한거임.

char szName[6] = "jusin"; 이렇게 하면 ㄱㅊ
쨌든 그래서 문자열 선언할때마다 딱 맞춰서 안하고 넉넉하게 하는것. 

*/

#include <iostream>

using namespace std;

int main() {
	// 배열은 앞에 s나 sz를 붙인다.
	
	{
		//char szName[5] = "jusin";	//error overflow
		char szName[6] = "jusin";	// ok 


		// 이렇게 출력해도 szName[0]의 주소가 나오는게 아니라 문자열이 쭉 나옴 -> 이건 cout의 기능떄문에 문자열이 나오는것.
		//cout은 char형만 예외적으로 문자열의 시작 주소를 받으면, 문자열이 끝나는 곳까지 출력하도록 만들어짐. 그래서 가능한거고
		//원래는 이렇게 하면 주소가 나오는게 정상
		cout << szName << endl;

		int arr[4] = { 1,2,3,4 };
		cout << arr << endl;	// 이건 int형이라 걍 주소가 나옴
	}

	//어쨌든 배열로하면 사이즈 문제가 자주 발생하기 때문에 보통은 포인터에 동적 할당써서 문자열 처리함 
	{
		//char* Name = "hello";	// 이건 가능 .. 이라는데 여기서 막네.. c++11이나 c++14이후로 막는듯 
		
		//문자열 복사 함수 
		// errno_t이거 타입디파인한건데 실체는 int임. 
		//( 복사 받을 문자열으 주소, 복사 받을 문자열의 버퍼 크기, 복사할 문자열의 주소)

		char szTemp[6] = "jusin";
		char szArray[16] = "serewerwrewr";
		errno_t strcpy_s()
	}
}

/*

과제1. 빙고 만들기
1~25 숫자를 5*5 상태로 출력하기

숫자 입력받고, 입력받은 숫자는  *로 출력하기 

가로줄에 *이 5개 또는 세로줄에 벼리 *개, 또는 대각선 방향으로 별이 5개면 빙고가 하나 증가함

5빙고가 되면 승리 

1	2	3
4	5	6
7	8	9

3입력시 
1	2	*
4	5	6
7	8	9
이렇게됨


과제2
숫자 이동시키기


0~24 를 5*5로 출력
숫자 입력받고, 넘버패드의 2,4,6,8을 이용하여 숫자 0의 위치를 이동시키는것.

0	1	2
3	4	5
6	7	8

넘버패드의 2를 누르면 

3	1	2
0	4	5	
6	7	8
이렇게됨

제일 위에있는데 8누르면 이동안함. 

알아서 구현하기




*/