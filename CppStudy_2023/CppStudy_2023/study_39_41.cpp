/* [ C++ study with TCP school 39 ~ 41part]
topic: 디폴트 인수 / 함수 오버로딩 / 인라인 함수 / 메크로 함수

--------------------------------------------------------------------------------------------------------------
* 디폴트 인수
	디폴트 인수 = 기본값이 미리 정의되어 있는 인수 
	함수를 호출할 때 인수를 전달하지 않으면, 함수는 자동으로 미리 정의되어 있는 디폴트 인수값을 사용함 

* 디폴트 인수 지정 규칙
	1. 함수의 원형에서만 지정가능
	2. 가장 오른쪽 매개변수부터 순서대로 지정가능
	   즉, 가운데나 왼쪽 변수만 지정하는건 불가능. 지정할거면 제일 오른쪽부터 해야함. 

--------------------------------------------------------------------------------------------------------------

* 함수 오버로딩 (Function overloading)이란?
	: 같은 이름의 함수를 중복하여 정의하는 것

* 주로 쓰임
	: 같은 기능을 하는 함수라도 , 다양한 매개변수 형식이 필요할 때

* "함수 오버로딩" 은 -> 객체 지향 프로그래밍의 특성인 "다형성(polymorphism)의 구현이다. 

	- 객체 지향 프로그래밍의 4가지 특징
		1. 추상화
		2. 캡슐화
		3. 상속
		4. 다형성
		
--------------------------------------------------------------------------------------------------------------

* C++에서 함수를 호출하는 과정
	함수를 호출하면 
	-> 스텍에 함수로 전달할 매개변수, 반환 주소값을 저장함
	-> 함수 내에 선언된 지역변수도 스택에 저장함
	-> 스텍에 저장된, 돌아갈 반환 주소값으로 이동해서 -> 스택에 저장된 함수 호출 정보를 제거함
	
	이 과정이 함수 호출시마다 발생하는데, 이 '함수 호출하는데 걸리는 시간' 을 잘 생각해보자
	- [ '함수를 수행하는 시간' > '함수 호출하는데 걸리는 시간' ] : 이런 경우는 호출하는데 걸리는 시간이 별로 신경쓰이지 않음. 
	- [ '함수를 수행하는 시간' < '함수 호출하는데 걸리는 시간' ] : 근데 이 경우는 배보다 배꼽이 큰거임
	=> 결론 ) 수행시간이 짧은 함수들은 정상적인 함수 호출과정을 거치기에는 너무 리소스가 아까움. 
	=> 해결방법 ) 그래서 인라인 함수를 사용하는 것. 
	
* 인라인 함수(inline function) 
	- 일반적인 함수 호출과정 거치지x
	- 함수의 모든 코드를 호출된 자리에 바로 삽입 ( 컴파일 할 때 > 코드상 함수 호출한 곳에 그냥 처음부터 함수 내용을 넣은후에, 컴파일 쫙 하는거임. '일반적인 호출과정' 없이) 
											  ( 그니까 이게 코드 쓸때는 걍 inline이 키워드만 추가되는 것 뿐이고, 실제로 코드 돌리는 중에 발생하는 차이인것)  

	-inline 키워드 :  함수의 원형 / 함수 선언 -> 둘중 한곳에만 표기해도됨 (근데 양쪽다 해도 상관없고, 그 편이 보기 좋을듯)

--------------------------------------------------------------------------------------------------------------

* 메크로 함수 
	주로 C에서 쓰던 문법으로, 인라인 함수와 거의 비슷한기능, 비슷한 용도로 쓰임

	#define [메크로 함수 이름] ([매개변수]) [함수 내용]
	-> 이떄, 함수 내용부분에서는 모든 인수를 다 괄호로 묶어야함. 
		EX) x + x를 하고싶으면
		   ((x) + (x)) 이렇게 써야함. 

*/

#include <iostream>
#define MECRO_FUNC(X) ((X)*(X))	 // 메크로 함수 

using namespace std;



// [디폴트 인수 예제 함수 ]
	void TestFunc_DefaultArgument(int i1 = 1, int i2 = 1);	// 이게 함수의 원형이다. 
	// void TestFunc_DefaultArgument(int i1 = 1, int i2 );  // 이건 불가능. 오른쪽부터 디폴트 넣어야함. 

// [함수 오버로딩 예제 함수]
	void Overloading_func(int i1);
	void Overloading_func(char ch1);
	void Overloading_func(int i1, string str1);

// [ 인라인 함수 예제 함수]
	inline void Inline_func1(int x) { cout << x << "를 받았습니다." << endl; }	  // 어차피 한줄이니까 걍 함수의 원형쓰는 곳에 냅다 함수 선언 해버려도 괜춘
	inline void Inline_func2(int x);	// 밑에 함수 선언하고 여기선 함수 원형 쓰는것. (일반적인 함수 사용과 같음)



int main() {
	// [ 디폴트 인수 ]
	{
		TestFunc_DefaultArgument(10); //i1만 전달하면 i2는 자동으로 디폴트 인수가 들어감
		TestFunc_DefaultArgument(10, 20);	 // 모든 인수에 값을 전달했으니, 디폴트 인수값말고 전달한 값들만 쓰임 
	}

	// [ 함수 오버로딩 ]
	{
		Overloading_func(10);
		Overloading_func('A');
		Overloading_func(100, "hello world");
	}
	
	// [ 인라인 함수 ]
	{
		Inline_func1(10);
		Inline_func2(20);
	}

	// [ 메크로 함수 ]
	{
		int result = MECRO_FUNC(10);
		cout << "메크로 함수 결과: " << result << endl;
		int x = 4;
		result = MECRO_FUNC(x+5);
		cout << "메크로 함수 결과: " << result << endl;
	}
	
}



void TestFunc_DefaultArgument(int i1, int i2) 	//이건 함수 선언
{								// 이건 함수 몸체
	cout << "i1: " << i1 << ", i2: " << i2 << endl;
}

void Overloading_func(int i1) { cout << "1. 오버로딩 함수 (int) : " << i1 << endl; }
void Overloading_func(char ch1) { cout << "2. 오버로딩 함수 (char) : " << ch1 << endl; }
void Overloading_func(int i1, string str1) { cout << "3. 오버로딩 함수 (int, string) : " << i1 << " / "<<str1 << endl; }

inline void Inline_func2(int x) { cout << x << "를 받았습니다." << endl; }